// notes.js

// your goal should be to identify good fits and apply to low amounts of places. 1-3 a day with a few day breaks where you work on technical thigns
// and do not interview stuff. 

// general pointers
//   -self-awareness and identifing strengths & weakness (lean into our strengths)
//   -you dont need to outrun the bear you just need to outrun your friend with you (seperate yourself)
//   -your trading the most valuable finite thing you have which is time to build someone elses bullshit
//   -remember you are interviewing them and can definitely control the conversation with almost everyone except executives and hiring managers

// setup
/* 
     1. Resume & Cover Letter's (template)
          -always export to PDF for signatures, security, quality, & deep linking
     3. Online Presence (twitter, blog, portfolio, groups)
          -twitter
          -groups [slack, dischord, reddit] => networking/meetups
          -blog
          -portfolio
               -> should be hosted and fully functioning including whats in it
               -> should be incredibly minimal (number of things)
     4. LinkedIn
          -filling out every portion, picture, header, linking every company, etc etc
          -privatize
          -turn on 'open to work' badge & recruiter thing
          -professional headshots (500$)
     5. Github
*/





// saftey & professionalism
//   -never put actual address or any super personal information (includes phone number[google]) unless!! its beneficial to say you live near there
//   -seperating your personal from perfesional online presence
//   -make your professional social oprofiles align wiht your real name and SUPER public



// intentions
//   -never MASS applying
//   -where and why you want to work somewhere => this should ultimately influence your resume, cover letter, what you talk in the interviews



// procedure
/* 
     1. Tailor every resume/cover letter to the specific job posting (customization) => pulling out keywords
     2. Unification of online presense
     3. Current (keep everything up to date)
     4. How to apply
          -always try to avoid an automatic system if possible
               => look up compnay or team on linkedin or website and linkedin stalk them and message the hiring manager directly or via twitter
*/


// tracking/feedback

//   -ATS
//   -link tracking (analytics on what to include)
//   -personal tracking system [google sheet, name of company, name of position, date applied, date heard abck from , point of contact, due dates, tech stack, beenfits package, location, salaray range, feedback]


// steps (debugging)
/* 
     1. Applying 
     2. Initial phone screen => internal recruiter/hr/bot 
     3. Another phone screen with senior member of team (also maybe zoom)
     4-7. Technical assessment (either on the spot or takehome => follow up to explain your code like a code review) another interview with team mebebers and another interview witht he hiring manager
     8. Meet with an executive (CTO, CFO, again with hiring manager)
     9. Offers & negotiations
*/



// preperation
//   -move this to monday





// burnout























// syntax & organization & nouns/verbs

// imperative => object oriented patterns
// declaritave => functional programming (FP)
// - building things w/ pure functions [predictable output & imutable parameters by the fx itself, have no side effects]
// - avoid shared state, mutable data, side effects
// - IMMUTABLE DATA!! 

// function composition => combine functions to make more functions

// JS runtime & interpretation (synchronicity)
// - whitespace removal 
// - scoping / hoisting
// - ASI
// - type casting 

// JS's 1st class functions

// execution context (lexical scoping) => call stacks (JS & NODE)
// JS === single threaded => LIFO stack 
// NODE === non-blocking I/O async =. event loop has 6 phases

// var, let, const => scoping / hoisting
// all the different fx's and thier unique propertioes => scoping hoisting

// inheritence patterns of JS => prototypal

// 4 pillars of OOP
// Inheritance, polymorphism, encapsulation, abstraction
// application state is usually shared and colocated with methods and objects



























